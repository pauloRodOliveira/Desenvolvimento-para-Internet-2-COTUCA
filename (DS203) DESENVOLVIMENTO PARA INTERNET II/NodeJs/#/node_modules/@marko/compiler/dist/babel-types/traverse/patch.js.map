{"version":3,"sources":["../../../src/babel-types/traverse/patch.js"],"names":["MARKO_TYPES","forEach","typeName","checkKey","assertKey","checkFn","t","assertFn","NodePath","prototype","opts","node","MARKO_ALIAS_TYPES","aliasName","originalProtoCheck","is","call","originalCrawl","Scope","crawl","patchedVisitors","WeakSet","path","originalTraverse","traverse","visitor","state","hoistableTagVarsByScope","Map","has","add","Object","assign","explode","MarkoTagBody","body","param","get","scope","registerBinding","MarkoTag","tag","tagVar","name","getBindingIdentifiers","curScope","binding","getBinding","parent","hoistableTagVars","set","references","length","movedBindings","ref","hasBinding","hoistableBinding","buildCodeFrameError","movedBinding","getScopeDepth","moveBindingTo","identifier","depth","cur"],"mappings":"aAAA;;AAEA;AACA;AACA,mD;;AAEAA,yBAAYC,OAAZ,CAAoB,CAAAC,QAAQ,KAAI;AAC9B,QAAMC,QAAQ,GAAI,KAAID,QAAS,EAA/B;AACA,QAAME,SAAS,GAAI,SAAQF,QAAS,EAApC;AACA,QAAMG,OAAO,GAAGC,CAAC,CAACH,QAAD,CAAjB;AACA,QAAMI,QAAQ,GAAGD,CAAC,CAACF,SAAD,CAAlB;AACAI,qBAASC,SAAT,CAAmBN,QAAnB,IAA+B,UAAUO,IAAV,EAAgB;AAC7C,WAAOL,OAAO,CAAC,KAAKM,IAAN,EAAYD,IAAZ,CAAd;AACD,GAFD;AAGAF,qBAASC,SAAT,CAAmBL,SAAnB,IAAgC,UAAUM,IAAV,EAAgB;AAC9CH,IAAAA,QAAQ,CAAC,KAAKI,IAAN,EAAYD,IAAZ,CAAR;AACD,GAFD;AAGD,CAXD;;AAaAE,+BAAkBX,OAAlB,CAA0B,CAAAY,SAAS,KAAI;AACrC,QAAMV,QAAQ,GAAI,KAAIU,SAAU,EAAhC;AACA,QAAMC,kBAAkB,GAAGN,mBAASC,SAAT,CAAmBN,QAAnB,CAA3B;AACAK,qBAASC,SAAT,CAAmBN,QAAnB,IAA+B,UAAUO,IAAV,EAAgB;AAC7C;AACEJ,MAAAA,CAAC,CAACS,EAAF,CAAKF,SAAL,EAAgB,KAAKF,IAArB,EAA2BD,IAA3B;AACAI,MAAAA,kBAAkB,CAACE,IAAnB,CAAwB,IAAxB,EAA8B,KAAKL,IAAnC,EAAyCD,IAAzC,CAFF;;AAID,GALD;AAMD,CATD;;AAWA;AACA;AACA,MAAMO,aAAa,GAAGC,gBAAMT,SAAN,CAAgBU,KAAtC;AACA,MAAMC,eAAe,GAAG,IAAIC,OAAJ,EAAxB;;AAEAH,gBAAMT,SAAN,CAAgBU,KAAhB,GAAwB,YAAY;AAClC,QAAMG,IAAI,GAAG,KAAKA,IAAlB;AACA,QAAMC,gBAAgB,GAAGD,IAAI,CAACE,QAA9B;AACAF,EAAAA,IAAI,CAACE,QAAL,GAAgB,UAAUC,OAAV,EAAmBC,KAAnB,EAA0B;AACxCA,IAAAA,KAAK,CAACC,uBAAN,GAAgC,IAAIC,GAAJ,EAAhC;AACAN,IAAAA,IAAI,CAACE,QAAL,GAAgBD,gBAAhB;;AAEA,QAAI,CAACH,eAAe,CAACS,GAAhB,CAAoBJ,OAApB,CAAL,EAAmC;AACjCL,MAAAA,eAAe,CAACU,GAAhB,CAAoBL,OAApB;AACAM,MAAAA,MAAM,CAACC,MAAP;AACER,wBAASS,OAAT,CAAiBR,OAAjB,CADF;AAEED,wBAASS,OAAT,CAAiB;AACfC,QAAAA,YAAY,CAACC,IAAD,EAAO;AACjB,eAAK,MAAMC,KAAX,IAAoBD,IAAI,CAACE,GAAL,CAAS,QAAT,CAApB,EAAwC;AACtCF,YAAAA,IAAI,CAACG,KAAL,CAAWC,eAAX,CAA2B,OAA3B,EAAoCH,KAApC;AACD;AACF,SALc;AAMfI,QAAAA,QAAQ,CAACC,GAAD,EAAMf,KAAN,EAAa;AACnB,gBAAMgB,MAAM,GAAGD,GAAG,CAACJ,GAAJ,CAAQ,KAAR,CAAf;AACA,cAAIK,MAAM,CAAC/B,IAAX,EAAiB;AACf8B,YAAAA,GAAG,CAACH,KAAJ,CAAUC,eAAV,CAA0B,OAA1B,EAAmCG,MAAnC,EAA2CD,GAA3C;AACA,iBAAK,MAAME,IAAX,IAAmBD,MAAM,CAACE,qBAAP,EAAnB,EAAmD;AACjD,kBAAIC,QAAQ,GAAGJ,GAAG,CAACH,KAAnB;AACA,oBAAMQ,OAAO,GAAGD,QAAQ,CAACE,UAAT,CAAoBJ,IAApB,CAAhB;;AAEA,qBAAQE,QAAQ,GAAGA,QAAQ,CAACG,MAA5B,EAAqC;AACnC,sBAAMC,gBAAgB;AACpBvB,gBAAAA,KAAK,CAACC,uBAAN,CAA8BU,GAA9B,CAAkCQ,QAAlC,CADF;;AAGA,oBAAII,gBAAJ,EAAsB;AACpBA,kBAAAA,gBAAgB,CAACN,IAAD,CAAhB,GAAyBM,gBAAgB,CAACN,IAAD,CAAhB;AACrB,sBADqB;AAErBG,kBAAAA,OAFJ;AAGD,iBAJD,MAIO;AACLpB,kBAAAA,KAAK,CAACC,uBAAN,CAA8BuB,GAA9B,CAAkCL,QAAlC,EAA4C;AAC1C,qBAACF,IAAD,GAAQG,OADkC,EAA5C;;AAGD;AACF;AACF;AACF;AACF,SA9Bc,EAAjB,CAFF;;;AAmCD;;AAED,SAAKtB,QAAL,CAAcC,OAAd,EAAuBC,KAAvB;;AAEA,QAAIA,KAAK,CAACyB,UAAN,CAAiBC,MAArB,EAA6B;AAC3B,YAAMC,aAAa,GAAG,IAAIzB,GAAJ,EAAtB;AACA,WAAK,MAAM0B,GAAX,IAAkB5B,KAAK,CAACyB,UAAxB,EAAoC;AAClC,cAAM,EAAER,IAAF,KAAWW,GAAG,CAAC3C,IAArB;AACA,YAAIkC,QAAQ,GAAGS,GAAG,CAAChB,KAAnB;AACA,YAAIO,QAAQ,CAACU,UAAT,CAAoBZ,IAApB,CAAJ,EAA+B;;AAE/B,WAAG;AACD,gBAAMa,gBAAgB;AACpB9B,UAAAA,KAAK,CAACC,uBAAN,CAA8BU,GAA9B,CAAkCQ,QAAlC,CADoB,qBACpB,sBAA8CF,IAA9C,CADF;;AAGA,cAAIa,gBAAJ,EAAsB;AACpB,gBAAIA,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B,oBAAMF,GAAG,CAACG,mBAAJ;AACJ,kGADI,CAAN;;AAGD;;AAED,kBAAMC,YAAY,GAAGL,aAAa,CAAChB,GAAd,CAAkBmB,gBAAlB,CAArB;AACA;AACE,aAACE,YAAD;AACAC,YAAAA,aAAa,CAACD,YAAD,CAAb,GAA8BC,aAAa,CAACd,QAAD,CAF7C;AAGE;AACAQ,cAAAA,aAAa,CAACH,GAAd,CAAkBM,gBAAlB,EAAoCX,QAApC;AACD;AACF;AACF,SAnBD,QAmBUA,QAAQ,GAAGA,QAAQ,CAACG,MAnB9B;AAoBD;;AAED,WAAK,MAAM,CAACF,OAAD,EAAUR,KAAV,CAAX,IAA+Be,aAA/B,EAA8C;AAC5CP,QAAAA,OAAO,CAACR,KAAR,CAAcsB,aAAd,CAA4Bd,OAAO,CAACe,UAAR,CAAmBlB,IAA/C,EAAqDL,KAArD;AACD;AACF;AACF,GA9ED;;AAgFArB,EAAAA,aAAa,CAACD,IAAd,CAAmB,IAAnB;AACAM,EAAAA,IAAI,CAACE,QAAL,GAAgBD,gBAAhB;AACD,CArFD;;AAuFA,SAASoC,aAAT,CAAuBrB,KAAvB,EAA8B;AAC5B,MAAIwB,KAAK,GAAG,CAAZ;AACA,MAAIC,GAAG,GAAGzB,KAAV;AACA,SAAQyB,GAAG,GAAGA,GAAG,CAACf,MAAlB,EAA2Bc,KAAK;AAChC,SAAOA,KAAP;AACD","sourcesContent":["import \"../types/patch\";\n\nimport * as t from \"@babel/types\";\nimport traverse, { NodePath, Scope } from \"@babel/traverse\";\nimport { MARKO_TYPES, MARKO_ALIAS_TYPES } from \"../types/definitions\";\n\nMARKO_TYPES.forEach(typeName => {\n  const checkKey = `is${typeName}`;\n  const assertKey = `assert${typeName}`;\n  const checkFn = t[checkKey];\n  const assertFn = t[assertKey];\n  NodePath.prototype[checkKey] = function (opts) {\n    return checkFn(this.node, opts);\n  };\n  NodePath.prototype[assertKey] = function (opts) {\n    assertFn(this.node, opts);\n  };\n});\n\nMARKO_ALIAS_TYPES.forEach(aliasName => {\n  const checkKey = `is${aliasName}`;\n  const originalProtoCheck = NodePath.prototype[checkKey];\n  NodePath.prototype[checkKey] = function (opts) {\n    return (\n      t.is(aliasName, this.node, opts) ||\n      originalProtoCheck.call(this, this.node, opts)\n    );\n  };\n});\n\n// Adds a one time patch to the scope collector visitors to include\n// Marko bindings for params and tag vars.\nconst originalCrawl = Scope.prototype.crawl;\nconst patchedVisitors = new WeakSet();\n\nScope.prototype.crawl = function () {\n  const path = this.path;\n  const originalTraverse = path.traverse;\n  path.traverse = function (visitor, state) {\n    state.hoistableTagVarsByScope = new Map();\n    path.traverse = originalTraverse;\n\n    if (!patchedVisitors.has(visitor)) {\n      patchedVisitors.add(visitor);\n      Object.assign(\n        traverse.explode(visitor),\n        traverse.explode({\n          MarkoTagBody(body) {\n            for (const param of body.get(\"params\")) {\n              body.scope.registerBinding(\"param\", param);\n            }\n          },\n          MarkoTag(tag, state) {\n            const tagVar = tag.get(\"var\");\n            if (tagVar.node) {\n              tag.scope.registerBinding(\"local\", tagVar, tag);\n              for (const name in tagVar.getBindingIdentifiers()) {\n                let curScope = tag.scope;\n                const binding = curScope.getBinding(name);\n\n                while ((curScope = curScope.parent)) {\n                  const hoistableTagVars =\n                    state.hoistableTagVarsByScope.get(curScope);\n\n                  if (hoistableTagVars) {\n                    hoistableTagVars[name] = hoistableTagVars[name]\n                      ? true\n                      : binding;\n                  } else {\n                    state.hoistableTagVarsByScope.set(curScope, {\n                      [name]: binding\n                    });\n                  }\n                }\n              }\n            }\n          }\n        })\n      );\n    }\n\n    this.traverse(visitor, state);\n\n    if (state.references.length) {\n      const movedBindings = new Map();\n      for (const ref of state.references) {\n        const { name } = ref.node;\n        let curScope = ref.scope;\n        if (curScope.hasBinding(name)) continue;\n\n        do {\n          const hoistableBinding =\n            state.hoistableTagVarsByScope.get(curScope)?.[name];\n\n          if (hoistableBinding) {\n            if (hoistableBinding === true) {\n              throw ref.buildCodeFrameError(\n                \"Ambiguous reference, variable was defined in multiple places and was not shadowed.\"\n              );\n            }\n\n            const movedBinding = movedBindings.get(hoistableBinding);\n            if (\n              !movedBinding ||\n              getScopeDepth(movedBinding) < getScopeDepth(curScope)\n            ) {\n              movedBindings.set(hoistableBinding, curScope);\n            }\n          }\n        } while ((curScope = curScope.parent));\n      }\n\n      for (const [binding, scope] of movedBindings) {\n        binding.scope.moveBindingTo(binding.identifier.name, scope);\n      }\n    }\n  };\n\n  originalCrawl.call(this);\n  path.traverse = originalTraverse;\n};\n\nfunction getScopeDepth(scope) {\n  let depth = 0;\n  let cur = scope;\n  while ((cur = cur.parent)) depth++;\n  return depth;\n}\n"],"file":"patch.js"}