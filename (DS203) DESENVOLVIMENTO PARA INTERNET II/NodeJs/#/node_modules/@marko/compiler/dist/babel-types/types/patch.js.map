{"version":3,"sources":["../../../src/babel-types/types/patch.js"],"names":["TYPES","VISITOR_KEYS","FLIPPED_ALIAS_KEYS","DEPRECATED_KEYS","is","getBindingIdentifiers","babelTypes","keys","MARKO_TYPES","forEach","typeName","definitions","type","Object","includes","push","lowerName","toLowerCase","slice","checkKey","assertKey","node","opts","assert","builder","apply","arguments","MARKO_ALIAS_TYPES","aliasName","originalCheck","generatedValidators","originalIsReferenced","referencedValidators","default","parent","grandparent","Error","JSON","stringify"],"mappings":"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","sourcesContent":["/* eslint-disable no-import-assign */\nimport * as babelTypes from \"@babel/types\";\nimport builder from \"@babel/types/lib/builders/builder\";\nimport defineType from \"@babel/types/lib/definitions/utils\";\nimport * as generatedValidators from \"@babel/types/lib/validators/generated\";\nimport * as referencedValidators from \"@babel/types/lib/validators/isReferenced\";\nimport definitions, { MARKO_TYPES, MARKO_ALIAS_TYPES } from \"./definitions\";\n\nconst {\n  TYPES,\n  VISITOR_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  DEPRECATED_KEYS,\n  is,\n  getBindingIdentifiers\n} = babelTypes;\n\ngetBindingIdentifiers.keys[\"MarkoTag\"] = [\"var\"];\ngetBindingIdentifiers.keys[\"MarkoTagBody\"] = [\"params\"];\n\nMARKO_TYPES.forEach(typeName => {\n  defineType(typeName, definitions[typeName]);\n});\n\nfor (const type of [\n  ...Object.keys(VISITOR_KEYS),\n  ...Object.keys(FLIPPED_ALIAS_KEYS),\n  ...Object.keys(DEPRECATED_KEYS)\n]) {\n  if (!TYPES.includes(type)) TYPES.push(type);\n}\n\nMARKO_TYPES.forEach(typeName => {\n  const lowerName = typeName[0].toLowerCase() + typeName.slice(1);\n  const checkKey = `is${typeName}`;\n  const assertKey = `assert${typeName}`;\n  babelTypes[checkKey] = (node, opts) => is(typeName, node, opts);\n  babelTypes[assertKey] = (node, opts) => assert(typeName, node, opts);\n  babelTypes[typeName] = babelTypes[lowerName] = function () {\n    return builder.apply(typeName, arguments);\n  };\n});\n\nMARKO_ALIAS_TYPES.forEach(aliasName => {\n  const checkKey = `is${aliasName}`;\n  const originalCheck = generatedValidators[checkKey];\n  generatedValidators[checkKey] = (node, opts) =>\n    is(aliasName, node, opts) || originalCheck(node, opts);\n});\n\nconst originalIsReferenced = referencedValidators.default;\nreferencedValidators.default = (node, parent, grandparent) => {\n  if (parent.type === \"MarkoTag\" || parent.type === \"MarkoTagBody\") {\n    return false;\n  }\n  return originalIsReferenced(node, parent, grandparent);\n};\n\nfunction assert(typeName, node, opts) {\n  if (!is(typeName, node, opts)) {\n    throw new Error(\n      `Expected type \"${typeName}\" with option ${JSON.stringify(\n        opts\n      )}, but instead got \"${node.type}\".`\n    );\n  }\n}\n"],"file":"patch.js"}